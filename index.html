<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heart Particle + Text Ring (1 file)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui}
    #ui{
      position:fixed; inset:12px 12px auto 12px; display:flex; gap:10px; flex-wrap:wrap;
      z-index:10; align-items:center; justify-content:space-between;
      pointer-events:none;
    }
    .pill{
      pointer-events:auto;
      color:#fff; font-size:12px; opacity:.9;
      padding:8px 10px; border-radius:999px;
      background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
      display:flex; gap:8px; align-items:center;
    }
    button,input{
      pointer-events:auto;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#fff; padding:7px 10px; border-radius:12px;
      font-weight:700; cursor:pointer; font-size:12px;
    }
    button:hover{ background:rgba(255,255,255,.12); }
    input{ font-weight:600; width:min(260px, 60vw); }
    #hint{
      position:fixed; bottom:12px; left:12px; right:12px;
      text-align:center; color:#fff; font-size:12px; opacity:.75;
      z-index:10; pointer-events:none;
    }
    canvas{display:block}
  </style>
</head>
<body>
  <div id="ui">
    <div class="pill">
      âœ¨ KÃ©o/chuá»™t Ä‘á»ƒ xoay â€¢ LÄƒn Ä‘á»ƒ zoom
    </div>
    <div class="pill">
      <span>Text:</span>
      <input id="text" value="Em yÃªu chá»“ng ðŸ’– | Cáº£m Æ¡n anh ðŸ«¶ | Chá»“ng yÃªu ðŸ˜³ | Bruh ðŸ¤¦" />
      <button id="apply">Apply</button>
    </div>
  </div>
  <div id="hint">Tip: mobile kÃ©o 1 ngÃ³n Ä‘á»ƒ xoay â€¢ 2 ngÃ³n Ä‘á»ƒ zoom</div>

  <!-- Three.js (CDN) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // --- Scene setup ---
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 4000);
    camera.position.set(0, 60, 240);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.rotateSpeed = 0.35;
    controls.zoomSpeed = 0.75;
    controls.minDistance = 110;
    controls.maxDistance = 520;

    // --- Starfield ---
    function makeStars(count=1500){
      const g = new THREE.BufferGeometry();
      const p = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        const r = 1200*Math.pow(Math.random(), 0.55);
        const th = Math.random()*Math.PI*2;
        const ph = Math.acos(2*Math.random()-1);
        p[i*3+0] = r*Math.sin(ph)*Math.cos(th);
        p[i*3+1] = r*Math.cos(ph);
        p[i*3+2] = r*Math.sin(ph)*Math.sin(th);
      }
      g.setAttribute('position', new THREE.BufferAttribute(p,3));
      const m = new THREE.PointsMaterial({ size: 1.2, sizeAttenuation:true, color:0xffffff, transparent:true, opacity:0.85 });
      const pts = new THREE.Points(g,m);
      return pts;
    }
    const stars = makeStars(2200);
    scene.add(stars);

    // --- Heart particle cloud ---
    // Heart curve in 2D, then extrude to 3D "puffy" volume.
    function heart2D(t){
      // classic heart param
      const x = 16*Math.pow(Math.sin(t),3);
      const y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
      return {x, y};
    }

    function makeHeartPoints(N=32000){
      const pos = new Float32Array(N*3);
      const col = new Float32Array(N*3);

      for(let i=0;i<N;i++){
        const t = Math.random()*Math.PI*2;
        const h = heart2D(t);

        // random fill inside the heart: scale radius toward center
        const s = Math.pow(Math.random(), 0.55); // more points near surface
        let x = h.x*s;
        let y = h.y*s;

        // turn 2D heart into 3D puffy shape
        const z = (Math.random()*2-1) * (18*(1-s)) + (Math.random()*2-1)*3;

        // scale + position: lift it up like your sample
        x *= 4.2;
        y *= 4.2;
        pos[i*3+0] = x;
        pos[i*3+1] = y + 120;
        pos[i*3+2] = z;

        // pink/purple gradient
        const ny = (y + 60) / 160; // ~0..1
        const r = 0.92;
        const g = 0.35 + 0.20*ny;
        const b = 0.90;
        col[i*3+0] = r;
        col[i*3+1] = g;
        col[i*3+2] = b;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      geo.setAttribute('color', new THREE.BufferAttribute(col,3));

      const mat = new THREE.PointsMaterial({
        size: 1.15,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      return new THREE.Points(geo, mat);
    }

    const heart = makeHeartPoints(36000);
    scene.add(heart);

    // --- Floating text ring (sprites) ---
    function makeTextSprite(text, fontSize=44){
      const pad = 18;

      const c = document.createElement('canvas');
      const ctx = c.getContext('2d');

      ctx.font = `700 ${fontSize}px system-ui, Segoe UI, Arial`;
      const metrics = ctx.measureText(text);
      const w = Math.ceil(metrics.width + pad*2);
      const h = Math.ceil(fontSize + pad*2);

      c.width = w;
      c.height = h;

      // draw
      ctx.clearRect(0,0,w,h);
      ctx.font = `700 ${fontSize}px system-ui, Segoe UI, Arial`;

      // glow
      ctx.shadowColor = 'rgba(255,120,220,0.85)';
      ctx.shadowBlur = 18;
      ctx.fillStyle = 'rgba(255,255,255,0.96)';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';
      ctx.fillText(text, w/2, h/2);

      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;

      const mat = new THREE.SpriteMaterial({
        map: tex,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      const spr = new THREE.Sprite(mat);
      // scale sprite in world units
      const scale = 0.55;
      spr.scale.set(w*scale*0.12, h*scale*0.12, 1);
      return spr;
    }

    const ringGroup = new THREE.Group();
    scene.add(ringGroup);

    function rebuildRing(phrases){
      // clear
      while(ringGroup.children.length){
        const ch = ringGroup.children.pop();
        if (ch.material?.map) ch.material.map.dispose();
        if (ch.material) ch.material.dispose();
      }

      const radius = 165;
      const y = 18; // below heart
      const count = Math.max(12, phrases.length*4);

      for(let i=0;i<count;i++){
        const txt = phrases[i % phrases.length];
        const spr = makeTextSprite(txt, 40);

        const ang = (i/count) * Math.PI*2;
        spr.position.set(
          Math.cos(ang)*radius,
          y + (Math.sin(ang*2)*6),
          Math.sin(ang)*radius
        );
        // face outward
        spr.userData.ang = ang;
        ringGroup.add(spr);
      }
    }

    function parsePhrases(raw){
      return raw.split('|').map(s=>s.trim()).filter(Boolean);
    }

    rebuildRing(parsePhrases(document.getElementById('text').value));

    document.getElementById('apply').addEventListener('click', () => {
      rebuildRing(parsePhrases(document.getElementById('text').value));
    });

    // --- Subtle falling hearts (tiny particles under ring) ---
    function makeFallingBits(N=1800){
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(N*3);
      const vel = new Float32Array(N*3);
      for(let i=0;i<N;i++){
        pos[i*3+0] = (Math.random()*2-1)*210;
        pos[i*3+1] = Math.random()*60;
        pos[i*3+2] = (Math.random()*2-1)*210;
        vel[i*3+0] = (Math.random()*2-1)*2.0;
        vel[i*3+1] = - (10 + Math.random()*26);
        vel[i*3+2] = (Math.random()*2-1)*2.0;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      geo.setAttribute('velocity', new THREE.BufferAttribute(vel,3));
      const mat = new THREE.PointsMaterial({
        size: 1.1,
        color: 0xffffff,
        transparent:true,
        opacity:0.55,
        blending: THREE.AdditiveBlending,
        depthWrite:false
      });
      return new THREE.Points(geo, mat);
    }
    const bits = makeFallingBits(2000);
    scene.add(bits);

    // --- Animation ---
    const clock = new THREE.Clock();
    function tick(){
      const t = clock.getElapsedTime();
      const dt = Math.min(0.033, clock.getDelta());

      // gentle rotations (like your sample)
      heart.rotation.y = t*0.12;
      heart.rotation.x = Math.sin(t*0.35)*0.05;

      ringGroup.rotation.y = -t*0.38;
      ringGroup.rotation.x = Math.sin(t*0.25)*0.06;

      // make sprites always face camera (sprites already do), but we can add slight bob & outward orientation
      for(const spr of ringGroup.children){
        const ang = spr.userData.ang ?? 0;
        spr.position.y = 18 + Math.sin(t*1.1 + ang*3)*7;
      }

      // stars slow drift
      stars.rotation.y = t*0.02;

      // falling bits update
      const p = bits.geometry.attributes.position;
      const v = bits.geometry.attributes.velocity;
      for(let i=0;i<p.count;i++){
        p.array[i*3+0] += v.array[i*3+0]*dt;
        p.array[i*3+1] += v.array[i*3+1]*dt;
        p.array[i*3+2] += v.array[i*3+2]*dt;

        // wrap
        if(p.array[i*3+1] < -40){
          p.array[i*3+0] = (Math.random()*2-1)*210;
          p.array[i*3+1] = 60 + Math.random()*40;
          p.array[i*3+2] = (Math.random()*2-1)*210;
        }
      }
      p.needsUpdate = true;

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();

    // --- Resize ---
    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    });
  </script>
</body>
</html>
