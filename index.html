<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Game ‚Äî N√© Kh·ªëi</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background:#0b1020; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
      user-select:none;
    }
    .wrap{
      width:min(920px, 96vw);
      display:grid; gap:12px;
    }
    .top{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      border-radius:14px; padding:10px 12px;
      backdrop-filter: blur(6px);
    }
    .title{ display:flex; flex-direction:column; gap:2px; }
    .title b{ font-size:14px; letter-spacing:.3px; }
    .title span{ font-size:12px; opacity:.85; }
    .hud{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
    .pill{
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);
      font-size:12px; opacity:.95;
    }
    button{
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#fff; padding:8px 10px; border-radius:12px;
      font-weight:600; cursor:pointer;
    }
    button:hover{ background:rgba(255,255,255,.12); }
    canvas{
      width:100%; aspect-ratio: 16/9;
      background: radial-gradient(1200px 600px at 50% 30%, rgba(120,170,255,.12), transparent 60%),
                  linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius:18px; border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
      touch-action:none;
    }
    .hint{
      font-size:12px; opacity:.75; text-align:center;
    }
    kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      font-size:11px;
      padding:2px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.25);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="title">
        <b>üéÆ N√© Kh·ªëi (1 file)</b>
        <span>N√© ch∆∞·ªõng ng·∫°i v·∫≠t, ƒÉn ƒëi·ªÉm. Ch·∫°y offline, h·ª£p GitHub Pages.</span>
      </div>
      <div class="hud">
        <div class="pill" id="score">Score: 0</div>
        <div class="pill" id="best">Best: 0</div>
        <div class="pill" id="level">Speed: 1.0√ó</div>
        <button id="btn">Start</button>
      </div>
    </div>

    <canvas id="c" width="1280" height="720"></canvas>
    <div class="hint">
      ƒêi·ªÅu khi·ªÉn: <kbd>‚Üê</kbd><kbd>‚Üí</kbd> ho·∫∑c <kbd>A</kbd><kbd>D</kbd> ‚Ä¢ Mobile: k√©o ngang ‚Ä¢ Pause: <kbd>P</kbd> ‚Ä¢ Restart: <kbd>R</kbd>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const uiScore = document.getElementById('score');
  const uiBest  = document.getElementById('best');
  const uiLevel = document.getElementById('level');
  const btn = document.getElementById('btn');

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);

  const BEST_KEY = 'ota_minigame_best_v1';
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  uiBest.textContent = `Best: ${best}`;

  // Game state
  let running = false;
  let paused = false;
  let lastT = 0;

  const world = {
    w: canvas.width,
    h: canvas.height,
    t: 0,
    score: 0,
    speed: 520, // base falling speed
    spawn: 0,
    spawnEvery: 0.75, // seconds
    blocks: [],
    particles: [],
  };

  const player = {
    x: world.w/2,
    y: world.h - 90,
    w: 90,
    h: 22,
    vx: 0,
    maxV: 920,
    accel: 2600,
    friction: 0.86
  };

  const input = { left:false, right:false, pointer:false, pointerX:0 };

  function reset() {
    world.t = 0;
    world.score = 0;
    world.speed = 520;
    world.spawn = 0;
    world.spawnEvery = 0.75;
    world.blocks = [];
    world.particles = [];
    player.x = world.w/2;
    player.vx = 0;
    paused = false;
    uiScore.textContent = 'Score: 0';
    uiLevel.textContent = 'Speed: 1.0√ó';
  }

  function start() {
    if (!running) {
      reset();
      running = true;
      btn.textContent = 'Pause';
      lastT = performance.now();
      requestAnimationFrame(loop);
      return;
    }
    // toggle pause
    paused = !paused;
    btn.textContent = paused ? 'Resume' : 'Pause';
  }

  function gameOver() {
    running = false;
    btn.textContent = 'Start';
    paused = false;

    if (world.score > best) {
      best = world.score;
      localStorage.setItem(BEST_KEY, String(best));
      uiBest.textContent = `Best: ${best}`;
    }
  }

  function spawnBlock() {
    // One or more blocks; sometimes create a "gap"
    const count = Math.random() < 0.18 ? 2 : 1;
    for (let i=0; i<count; i++) {
      const bw = rand(60, 160);
      const bx = rand(40, world.w - 40 - bw);
      world.blocks.push({
        x: bx, y: -40,
        w: bw, h: rand(22, 34),
        vy: world.speed * rand(0.9, 1.25),
        kind: Math.random() < 0.18 ? 'bonus' : 'danger'
      });
    }
  }

  function rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x &&
           a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function burst(x, y, n=14) {
    for (let i=0;i<n;i++){
      world.particles.push({
        x, y,
        vx: rand(-220, 220),
        vy: rand(-280, 120),
        life: rand(0.25, 0.75),
        r: rand(2, 5)
      });
    }
  }

  function update(dt) {
    world.t += dt;

    // difficulty ramp
    const mult = 1 + Math.min(2.2, world.t / 30); // up to ~3.2x
    world.speed = 520 * mult;
    world.spawnEvery = Math.max(0.32, 0.75 - world.t * 0.008);

    uiLevel.textContent = `Speed: ${mult.toFixed(1)}√ó`;

    // Input -> velocity
    let ax = 0;
    if (input.left) ax -= player.accel;
    if (input.right) ax += player.accel;

    // touch drag
    if (input.pointer) {
      const dx = input.pointerX - player.x;
      ax += clamp(dx * 8, -player.accel*1.2, player.accel*1.2);
    }

    player.vx += ax * dt;
    player.vx = clamp(player.vx, -player.maxV, player.maxV);
    player.vx *= Math.pow(player.friction, dt * 60);
    player.x += player.vx * dt;
    player.x = clamp(player.x, player.w/2 + 18, world.w - player.w/2 - 18);

    // Spawn
    world.spawn += dt;
    if (world.spawn >= world.spawnEvery) {
      world.spawn = 0;
      spawnBlock();
    }

    // Move blocks & collisions
    const pRect = {
      x: player.x - player.w/2,
      y: player.y - player.h/2,
      w: player.w,
      h: player.h
    };

    for (const b of world.blocks) {
      b.y += b.vy * dt;

      const bRect = { x:b.x, y:b.y, w:b.w, h:b.h };

      if (rectsOverlap(pRect, bRect)) {
        if (b.kind === 'bonus') {
          // score bonus
          world.score += 25;
          uiScore.textContent = `Score: ${world.score}`;
          burst(player.x, player.y, 18);
          b.y = world.h + 999; // remove
        } else {
          burst(player.x, player.y, 36);
          gameOver();
          return;
        }
      }

      // passed safely
      if (!b.counted && b.y > player.y + 40) {
        b.counted = true;
        world.score += (b.kind === 'danger') ? 5 : 0;
        uiScore.textContent = `Score: ${world.score}`;
      }
    }

    // cleanup blocks
    world.blocks = world.blocks.filter(b => b.y < world.h + 60);

    // particles
    for (const p of world.particles) {
      p.life -= dt;
      p.vy += 420 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
    }
    world.particles = world.particles.filter(p => p.life > 0);
  }

  function draw() {
    ctx.clearRect(0,0,world.w,world.h);

    // background grid
    ctx.globalAlpha = 0.15;
    ctx.beginPath();
    for (let x=40; x<world.w; x+=80){ ctx.moveTo(x,0); ctx.lineTo(x,world.h); }
    for (let y=40; y<world.h; y+=80){ ctx.moveTo(0,y); ctx.lineTo(world.w,y); }
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.globalAlpha = 1;

    // blocks
    for (const b of world.blocks) {
      ctx.beginPath();
      const r = 10;
      roundRect(ctx, b.x, b.y, b.w, b.h, r);
      if (b.kind === 'bonus') {
        ctx.fillStyle = 'rgba(80,200,255,.85)';
      } else {
        ctx.fillStyle = 'rgba(255,120,120,.85)';
      }
      ctx.fill();

      // highlight
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      roundRect(ctx, b.x+2, b.y+2, b.w-4, Math.max(6, b.h*0.42), r);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // player
    const px = player.x - player.w/2;
    const py = player.y - player.h/2;

    ctx.beginPath();
    roundRect(ctx, px, py, player.w, player.h, 12);
    ctx.fillStyle = 'rgba(180,220,255,.95)';
    ctx.fill();

    // player glow
    ctx.globalAlpha = 0.22;
    ctx.beginPath();
    roundRect(ctx, px-8, py-8, player.w+16, player.h+16, 16);
    ctx.fillStyle = 'rgba(180,220,255,1)';
    ctx.fill();
    ctx.globalAlpha = 1;

    // particles
    for (const p of world.particles) {
      ctx.globalAlpha = clamp(p.life*1.6, 0, 1);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // overlay text
    if (!running) {
      overlayText('B·∫•m Start ƒë·ªÉ ch∆°i', 'N√© kh·ªëi ƒë·ªè ‚Ä¢ ƒÇn kh·ªëi xanh');
    } else if (paused) {
      overlayText('T·∫°m d·ª´ng', 'B·∫•m Resume ho·∫∑c ph√≠m P');
    }
  }

  function overlayText(a, b) {
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fillRect(0,0,world.w,world.h);

    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '700 54px system-ui';
    ctx.fillText(a, world.w/2, world.h/2 - 10);

    ctx.globalAlpha = 0.85;
    ctx.font = '400 22px system-ui';
    ctx.fillText(b, world.w/2, world.h/2 + 34);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r) {
    r = Math.min(r, w/2, h/2);
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function loop(now) {
    if (!running) { draw(); return; }
    const dt = Math.min(0.033, (now - lastT) / 1000);
    lastT = now;

    if (!paused) update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // Controls
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') input.left = true;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') input.right = true;

    if (e.key.toLowerCase() === 'p' && running) {
      paused = !paused;
      btn.textContent = paused ? 'Resume' : 'Pause';
    }
    if (e.key.toLowerCase() === 'r') {
      if (!running) start();
      else reset();
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') input.left = false;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') input.right = false;
  });

  // Touch / pointer drag
  canvas.addEventListener('pointerdown', (e) => {
    input.pointer = true;
    const rect = canvas.getBoundingClientRect();
    input.pointerX = (e.clientX - rect.left) * (canvas.width / rect.width);
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener('pointermove', (e) => {
    if (!input.pointer) return;
    const rect = canvas.getBoundingClientRect();
    input.pointerX = (e.clientX - rect.left) * (canvas.width / rect.width);
  });
  canvas.addEventListener('pointerup', () => input.pointer = false);
  canvas.addEventListener('pointercancel', () => input.pointer = false);

  btn.addEventListener('click', start);

  // initial draw
  draw();
})();
</script>
</body>
</html>
